The [preceding technique](obsidian://open?vault=security-notes&file=Offensive%20Security%2FWeb%20Application%20Security%2FServer-side%20Vulnerabilities%2FXXE%20Injection%2FBlind%20XXE%20Injection%2FRetrieve%20Data%20via%20Error%20Messages) works fine with an external DTD, but it won't normally work with an internal DTD that is fully specified within the `DOCTYPE` element. This is because external DTDs allows us to include one entity inside another one, but this is prohibited in the internal DTD syntax (Some parsers might tolerate it, but many do not).

In this situation, it might still be possible to trigger an error message containing sensitive data, by abusing a loophole in the XML language specification. If a document's DTD uses a hybrid of internal and external DTD declarations, then the internal DTD can redefine entities that are declared in the external DTD. When this happens, the restrictions is relaxed.

This means that an attacker can use the [error-based XXE technique](obsidian://open?vault=security-notes&file=Offensive%20Security%2FWeb%20Application%20Security%2FServer-side%20Vulnerabilities%2FXXE%20Injection%2FBlind%20XXE%20Injection%2FRetrieve%20Data%20via%20Error%20Messages) from within an internal DTD, provided the parameter entity that they use is redefining an entity that is declared within an external DTD. However, if out-of-band connections are blocked, then the external DTD being used must be a file that exists on the local filesystem of the server.

For example, imagine a local DTD file on the server filesystem is located at `/usr/local/app/scheme.dtd`, and this DTD file defines an entity called `custom_entity`. An attacker can trigger an error message containing the `/etc/passwd` contents by submitting a hybrid DTD:
```dtd
<!DOCTYPE foo [
	<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
	<!ENTITY % custom_entity '
		<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
		<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
		&#x25;eval;
		&#x25;error;
	'>
	%local_dtd;
]>
```
## Locating An Existing DTD file to Repurpose
Since this attack involves repurposing an existing DTD within the server filesystem, a key requirement is to locate a suitable file. This is actually straightforward, because an application might return any error messages thrown by the XML parser, which can be used to enumerate local DTD files just by attempting to load them from within the internal DTD.

For example, Linux systems using the GNOME desktop environment often have a DTD file at `/usr/share/yelp/dtd/docbookx.dtd`. Submit the following XXE payload to test if this file is present:
```dtd
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Windows systems also have an always-existing DTD file located at: `C:\Windows\System32\wbem\xml\cim20.dtd`.

After confirming the existence of common DTD files that is present, an attacker must obtain a copy of the file and review it to find an entity that can be redefined. Since many common systems that include DTD files are open source, obtaining such copy is as easy as doing a simple Google search.