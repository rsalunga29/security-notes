The [preceding technique](obsidian://open?vault=security-notes&file=Offensive%20Security%2FWeb%20Application%20Security%2FServer-side%20Vulnerabilities%2FXXE%20Injection%2FBlind%20XXE%20Injection%2FRetrieve%20Data%20via%20Error%20Messages) works fine with an external DTD, but it won't normally work with an internal DTD that is fully specified within the `DOCTYPE` element. This is because external DTDs allow us to include one entity inside another one, but this is prohibited in the internal DTD syntax (Some parsers might tolerate it, but many do not).

In the scenario that data exfiltration via out-of-band connection does not work, and loading an external DTD from a remote server is not allowed due to out-of-band interactions being blocked. Another alternative is to repurpose a local DTD file.
## Locating an existing DTD file to repurpose
Since this attack involves repurposing an existing DTD within the server filesystem, a key requirement is to locate a suitable file. This is actually straightforward, because an application might return any error messages thrown by the XML parser, which can be used to enumerate local DTD files just by attempting to load them from within the internal DTD.

For example, Linux systems using the GNOME desktop environment often have a DTD file at `/usr/share/yelp/dtd/docbookx.dtd`. Submit the following XXE payload to test if this file is present:
```dtd
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
After confirming the existence of common DTD files that is present, an attacker must obtain a copy of the file and review it to find an entity that can be redefined. Since many common systems that include DTD files are open source, obtaining such copy is as easy as doing a simple Google search.