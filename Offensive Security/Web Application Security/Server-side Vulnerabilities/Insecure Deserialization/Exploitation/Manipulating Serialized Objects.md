Simply changing an attribute in a serialized object is one of the most basic deserialization exploit. As the object state is persisted, study the serialized data to identify and edit interesting values, a malicious object can then be passed into the application via its deserialization process.

This exploit can be approached in two ways:
1. edit the object directly in its byte stream form
2. write a short script in the corresponding language to create and serialized the new object.
## Modifying object attributes
As long as the attacker preserves a valid serialized object or its format, the deserialization process will create a server-side object with the modified attribute values.

For example, an application uses a serialized `User` object to store data about a user's session in a cookie.
```http
GET /authenticate HTTP/1.1
Host: normal-website.com
...
Cookie: Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjA7fQ==
```
An attacker can simply Base64 decode the cookie value and find the following byte stream:
```txt
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```
The `isAdmin` will be of obvious interest to the attacker, who can simply change the boolean value of the attribute to `1` (true), re-encode the object, and overwrite their current cookie, allowing their account to admin privileges.

This kind of scenario is very rare in the wild, however, if the application uses the following code to check whether the user is an admin or a normal user:
```php
$user = unserialized($_COOKIE);
if ($user->isAdmin === true) {
	// allow access to admin
}
```
This vulnerable code lacks proper validation to determine the authenticity of the serialized object. It would instantiate a `User` object based on the data from the cookie, including the modified `isAdmin` attribute.
## Modifying data types
An attacker can also modify the data types of a serialized object, leading to unexpected data types being processed by the deserialization process.

PHP-based logic is particularly vulnerable to this kind of manipulation due to the behavior of its loose comparison operator (`==`) when comparing different data types. For example, when you perform loose comparison between an integer and a string `5 == "5"`, PHP will attempt to convert the string into an integer, thus the result being `true`.

Another example is the following, wherein PHP will attempt to convert any alphanumeric string that starts with a number, into an integer-based val