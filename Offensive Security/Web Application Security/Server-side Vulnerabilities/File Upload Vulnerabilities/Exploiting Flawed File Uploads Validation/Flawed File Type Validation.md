When submitting HTML forms, the browser typically sends the provided data in `POST` HTTP request with the `Content-Type` value of `application/x-www-form-url-encoded`. Most of the time this works, however it isn't suitable for sending large amounts of binary data, such as an image or PDF file. In this case the `multipart/form-data` is more suitable.

Consider a form containing fields for uploading an image, providing a description of it, and entering your username. Submitting the form will result in a request like this:
```http
POST /images HTTP/1.1
Host: normal-website.com
Content-Length: 12345
Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="image"; filename="example.jpg"
Content-Type: image/jpeg

[...binary content of example.jpg...]

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="description"

This is an interesting description of my image.

---------------------------012345678901234567890123456
Content-Disposition: form-data; name="username"

wiener
---------------------------012345678901234567890123456--
```
Notice that the message body is split into separate parts for each of the form's inputs, where each part contains `Content-Disposition` header that provides basic information about the input field it relates to. These parts may also contain `Content-Type` header, which tells the server the MIME type of the data being submitted.

However, using `Content-Type` filtering alone isn't secure at all, as this can be [bypassed entirely](obsidian://open?vault=security-notes&file=Offensive%20Security%2FWeb%20Application%20Security%2FServer-side%20Vulnerabilities%2FFile%20Upload%20Vulnerabilities%2FBypassing%20File%20Upload%20Filtering%2FClient-side%2FContent-Type%20Restriction%20Bypass).